// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: documents.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const countDocuments = `-- name: CountDocuments :one
SELECT COUNT(*) 
FROM documents 
WHERE workspace_id = $1 
  AND deleted_at IS NULL
  AND ($2::uuid IS NULL OR directory_id = $2)
`

type CountDocumentsParams struct {
	WorkspaceID uuid.UUID     `json:"workspace_id"`
	DirectoryID uuid.NullUUID `json:"directory_id"`
}

func (q *Queries) CountDocuments(ctx context.Context, arg CountDocumentsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDocuments, arg.WorkspaceID, arg.DirectoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDocument = `-- name: CreateDocument :one
INSERT INTO documents (
    workspace_id, 
    directory_id, 
    file_id, 
    name, 
    tags, 
    status,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, 'uploaded', now(), now()
)
RETURNING id, workspace_id, directory_id, file_id, name, tags, metadata, status, processed_at, created_at, updated_at, deleted_at
`

type CreateDocumentParams struct {
	WorkspaceID uuid.UUID     `json:"workspace_id"`
	DirectoryID uuid.NullUUID `json:"directory_id"`
	FileID      uuid.UUID     `json:"file_id"`
	Name        string        `json:"name"`
	Tags        []string      `json:"tags"`
}

func (q *Queries) CreateDocument(ctx context.Context, arg CreateDocumentParams) (Document, error) {
	row := q.db.QueryRowContext(ctx, createDocument,
		arg.WorkspaceID,
		arg.DirectoryID,
		arg.FileID,
		arg.Name,
		pq.Array(arg.Tags),
	)
	var i Document
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.DirectoryID,
		&i.FileID,
		&i.Name,
		pq.Array(&i.Tags),
		&i.Metadata,
		&i.Status,
		&i.ProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteDocument = `-- name: DeleteDocument :exec
UPDATE documents 
SET 
    deleted_at = now(),
    updated_at = now()
WHERE id = $1 
  AND workspace_id = $2
`

type DeleteDocumentParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) DeleteDocument(ctx context.Context, arg DeleteDocumentParams) error {
	_, err := q.db.ExecContext(ctx, deleteDocument, arg.ID, arg.WorkspaceID)
	return err
}

const getDocument = `-- name: GetDocument :one
SELECT 
    d.id,
    d.workspace_id,
    d.directory_id,
    d.file_id,
    d.name,
    d.tags,
    d.status,
    d.created_at,
    d.updated_at,
    f.size_bytes,
    f.mime_type,
    f.sha256_hash,
    f.minio_bucket,
    f.minio_key
FROM documents d
INNER JOIN files f ON d.file_id = f.id
WHERE d.id = $1 
  AND d.workspace_id = $2 
  AND d.deleted_at IS NULL
`

type GetDocumentParams struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

type GetDocumentRow struct {
	ID          uuid.UUID     `json:"id"`
	WorkspaceID uuid.UUID     `json:"workspace_id"`
	DirectoryID uuid.NullUUID `json:"directory_id"`
	FileID      uuid.UUID     `json:"file_id"`
	Name        string        `json:"name"`
	Tags        []string      `json:"tags"`
	Status      string        `json:"status"`
	CreatedAt   time.Time     `json:"created_at"`
	UpdatedAt   time.Time     `json:"updated_at"`
	SizeBytes   int64         `json:"size_bytes"`
	MimeType    string        `json:"mime_type"`
	Sha256Hash  string        `json:"sha256_hash"`
	MinioBucket string        `json:"minio_bucket"`
	MinioKey    string        `json:"minio_key"`
}

func (q *Queries) GetDocument(ctx context.Context, arg GetDocumentParams) (GetDocumentRow, error) {
	row := q.db.QueryRowContext(ctx, getDocument, arg.ID, arg.WorkspaceID)
	var i GetDocumentRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.DirectoryID,
		&i.FileID,
		&i.Name,
		pq.Array(&i.Tags),
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SizeBytes,
		&i.MimeType,
		&i.Sha256Hash,
		&i.MinioBucket,
		&i.MinioKey,
	)
	return i, err
}

const listDocuments = `-- name: ListDocuments :many
SELECT 
    d.id,
    d.workspace_id,
    d.directory_id,
    d.file_id,
    d.name,
    d.tags,
    d.status,
    d.created_at,
    d.updated_at,
    f.size_bytes,
    f.mime_type
FROM documents d
INNER JOIN files f ON d.file_id = f.id
WHERE d.workspace_id = $1 
  AND d.deleted_at IS NULL
  AND ($4::uuid IS NULL OR d.directory_id = $4)
ORDER BY d.created_at DESC
LIMIT $2 OFFSET $3
`

type ListDocumentsParams struct {
	WorkspaceID uuid.UUID     `json:"workspace_id"`
	Limit       int32         `json:"limit"`
	Offset      int32         `json:"offset"`
	DirectoryID uuid.NullUUID `json:"directory_id"`
}

type ListDocumentsRow struct {
	ID          uuid.UUID     `json:"id"`
	WorkspaceID uuid.UUID     `json:"workspace_id"`
	DirectoryID uuid.NullUUID `json:"directory_id"`
	FileID      uuid.UUID     `json:"file_id"`
	Name        string        `json:"name"`
	Tags        []string      `json:"tags"`
	Status      string        `json:"status"`
	CreatedAt   time.Time     `json:"created_at"`
	UpdatedAt   time.Time     `json:"updated_at"`
	SizeBytes   int64         `json:"size_bytes"`
	MimeType    string        `json:"mime_type"`
}

func (q *Queries) ListDocuments(ctx context.Context, arg ListDocumentsParams) ([]ListDocumentsRow, error) {
	rows, err := q.db.QueryContext(ctx, listDocuments,
		arg.WorkspaceID,
		arg.Limit,
		arg.Offset,
		arg.DirectoryID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDocumentsRow
	for rows.Next() {
		var i ListDocumentsRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.DirectoryID,
			&i.FileID,
			&i.Name,
			pq.Array(&i.Tags),
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SizeBytes,
			&i.MimeType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
