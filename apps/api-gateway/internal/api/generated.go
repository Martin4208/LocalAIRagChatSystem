// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for AnalysisAnalysisType.
const (
	AnalysisAnalysisTypeEntityRecognition AnalysisAnalysisType = "entity_recognition"
	AnalysisAnalysisTypeGraphGeneration   AnalysisAnalysisType = "graph_generation"
	AnalysisAnalysisTypeKeywordExtraction AnalysisAnalysisType = "keyword_extraction"
	AnalysisAnalysisTypeSentimentAnalysis AnalysisAnalysisType = "sentiment_analysis"
	AnalysisAnalysisTypeSummary           AnalysisAnalysisType = "summary"
)

// Defines values for AnalysisResultResultType.
const (
	AnalysisResultResultTypeGraph AnalysisResultResultType = "graph"
	AnalysisResultResultTypeImage AnalysisResultResultType = "image"
	AnalysisResultResultTypeJson  AnalysisResultResultType = "json"
	AnalysisResultResultTypeText  AnalysisResultResultType = "text"
)

// Defines values for AnalysisStatus.
const (
	AnalysisStatusCompleted AnalysisStatus = "completed"
	AnalysisStatusFailed    AnalysisStatus = "failed"
	AnalysisStatusPending   AnalysisStatus = "pending"
	AnalysisStatusRunning   AnalysisStatus = "running"
)

// Defines values for ChatMessageRole.
const (
	Assistant ChatMessageRole = "assistant"
	System    ChatMessageRole = "system"
	User      ChatMessageRole = "user"
)

// Defines values for FileMetadataStatus.
const (
	FileMetadataStatusFailed     FileMetadataStatus = "failed"
	FileMetadataStatusProcessed  FileMetadataStatus = "processed"
	FileMetadataStatusProcessing FileMetadataStatus = "processing"
	FileMetadataStatusUploaded   FileMetadataStatus = "uploaded"
)

// Defines values for CreateAnalysisJSONBodyAnalysisType.
const (
	CreateAnalysisJSONBodyAnalysisTypeEntityRecognition CreateAnalysisJSONBodyAnalysisType = "entity_recognition"
	CreateAnalysisJSONBodyAnalysisTypeGraphGeneration   CreateAnalysisJSONBodyAnalysisType = "graph_generation"
	CreateAnalysisJSONBodyAnalysisTypeKeywordExtraction CreateAnalysisJSONBodyAnalysisType = "keyword_extraction"
	CreateAnalysisJSONBodyAnalysisTypeSentimentAnalysis CreateAnalysisJSONBodyAnalysisType = "sentiment_analysis"
	CreateAnalysisJSONBodyAnalysisTypeSummary           CreateAnalysisJSONBodyAnalysisType = "summary"
)

// Defines values for CreateAnalysisJSONBodyConfigLanguage.
const (
	En CreateAnalysisJSONBodyConfigLanguage = "en"
	Ja CreateAnalysisJSONBodyConfigLanguage = "ja"
)

// Analysis defines model for Analysis.
type Analysis struct {
	AnalysisType AnalysisAnalysisType `json:"analysis_type"`
	CompletedAt  *time.Time           `json:"completed_at"`

	// Config Analysis-specific configuration
	Config      *map[string]interface{} `json:"config"`
	CreatedAt   time.Time               `json:"created_at"`
	Description *string                 `json:"description"`

	// ErrorMessage Error details if status is 'failed'
	ErrorMessage *string            `json:"error_message"`
	Id           openapi_types.UUID `json:"id"`
	StartedAt    *time.Time         `json:"started_at"`

	// Status Analysis job status
	Status      AnalysisStatus     `json:"status"`
	Title       string             `json:"title"`
	UpdatedAt   time.Time          `json:"updated_at"`
	WorkspaceId openapi_types.UUID `json:"workspace_id"`
}

// AnalysisAnalysisType defines model for Analysis.AnalysisType.
type AnalysisAnalysisType string

// AnalysisResult defines model for AnalysisResult.
type AnalysisResult struct {
	AnalysisId openapi_types.UUID `json:"analysis_id"`

	// Content Result data (structure depends on result_type)
	Content   *map[string]interface{} `json:"content,omitempty"`
	CreatedAt time.Time               `json:"created_at"`
	Id        openapi_types.UUID      `json:"id"`

	// ImageUrl URL to generated image (if result_type=image)
	ImageUrl *string `json:"image_url"`

	// Metadata Additional metadata about the result
	Metadata *map[string]interface{} `json:"metadata"`

	// ResultType Type of result content
	ResultType AnalysisResultResultType `json:"result_type"`
}

// AnalysisResultResultType Type of result content
type AnalysisResultResultType string

// AnalysisStatus Analysis job status
type AnalysisStatus string

// Chat defines model for Chat.
type Chat struct {
	CreatedAt time.Time `json:"created_at"`

	// FilterConfig Configuration for filtering RAG search scope
	FilterConfig *FilterConfig      `json:"filter_config,omitempty"`
	Id           openapi_types.UUID `json:"id"`

	// LastMessageAt Timestamp of the last message
	LastMessageAt *time.Time `json:"last_message_at"`

	// MessageCount Total number of messages in this chat
	MessageCount *int               `json:"message_count,omitempty"`
	Title        string             `json:"title"`
	UpdatedAt    time.Time          `json:"updated_at"`
	WorkspaceId  openapi_types.UUID `json:"workspace_id"`
}

// ChatMessage defines model for ChatMessage.
type ChatMessage struct {
	ChatId    openapi_types.UUID `json:"chat_id"`
	Content   string             `json:"content"`
	CreatedAt time.Time          `json:"created_at"`

	// DocumentRefs References to source documents (RAG citations)
	DocumentRefs *[]DocumentReference `json:"document_refs,omitempty"`
	Id           openapi_types.UUID   `json:"id"`

	// MessageIndex Sequential index within the chat (0-based)
	MessageIndex int             `json:"message_index"`
	Role         ChatMessageRole `json:"role"`
}

// ChatMessageRole defines model for ChatMessage.Role.
type ChatMessageRole string

// CreateGraphRequest defines model for CreateGraphRequest.
type CreateGraphRequest struct {
	GraphType *string `json:"graph_type"`
	Title     string  `json:"title"`
}

// DocumentReference defines model for DocumentReference.
type DocumentReference struct {
	ChunkIndex int `json:"chunk_index"`

	// ContentPreview Short preview of the chunk content
	ContentPreview *string            `json:"content_preview,omitempty"`
	DocumentId     openapi_types.UUID `json:"document_id"`
	DocumentName   *string            `json:"document_name,omitempty"`

	// PageNumber Page number in the source document (1-based)
	PageNumber *int `json:"page_number"`

	// Score Relevance score (0.0 - 1.0)
	Score float32 `json:"score"`
}

// Error defines model for Error.
type Error struct {
	Error *struct {
		Code      *string                 `json:"code,omitempty"`
		Details   *map[string]interface{} `json:"details,omitempty"`
		Message   *string                 `json:"message,omitempty"`
		RequestId *string                 `json:"request_id,omitempty"`
		Timestamp *string                 `json:"timestamp,omitempty"`
	} `json:"error,omitempty"`
}

// FileListResponse defines model for FileListResponse.
type FileListResponse struct {
	Files []FileMetadata `json:"files"`

	// Total Total number of files matching the query
	Total int `json:"total"`
}

// FileMetadata defines model for FileMetadata.
type FileMetadata struct {
	CreatedAt time.Time `json:"createdAt"`

	// FileName Original filename
	FileName string             `json:"fileName"`
	Id       openapi_types.UUID `json:"id"`

	// MimeType MIME type (e.g., application/pdf)
	MimeType string `json:"mimeType"`

	// Sha256Hash SHA256 hash of file content
	Sha256Hash *string `json:"sha256Hash,omitempty"`

	// SizeBytes File size in bytes
	SizeBytes int64 `json:"sizeBytes"`

	// Status Document processing status
	Status *FileMetadataStatus `json:"status,omitempty"`

	// Tags File tags for categorization
	Tags *[]string `json:"tags"`
}

// FileMetadataStatus Document processing status
type FileMetadataStatus string

// FileUploadResponse defines model for FileUploadResponse.
type FileUploadResponse struct {
	CreatedAt time.Time          `json:"createdAt"`
	FileName  string             `json:"fileName"`
	Id        openapi_types.UUID `json:"id"`
	MimeType  string             `json:"mimeType"`

	// Sha256Hash SHA256 hash for deduplication
	Sha256Hash *string `json:"sha256Hash,omitempty"`
	SizeBytes  int64   `json:"sizeBytes"`
}

// FilterConfig Configuration for filtering RAG search scope
type FilterConfig struct {
	// DirectoryIds Search within specific directories
	DirectoryIds *[]openapi_types.UUID `json:"directory_ids,omitempty"`

	// DocumentIds Specific documents to search (empty = all)
	DocumentIds *[]openapi_types.UUID `json:"document_ids,omitempty"`

	// Tags Filter by document tags
	Tags *[]string `json:"tags,omitempty"`
}

// Graph defines model for Graph.
type Graph struct {
	CreatedAt time.Time          `json:"created_at"`
	Edges     []GraphEdge        `json:"edges"`
	GraphType *string            `json:"graph_type"`
	Id        openapi_types.UUID `json:"id"`

	// LayoutConfig Force-graph layout configuration (physics, zoom, etc.)
	LayoutConfig *map[string]interface{} `json:"layout_config"`
	Nodes        []GraphNode             `json:"nodes"`
	Title        string                  `json:"title"`
	UpdatedAt    time.Time               `json:"updated_at"`
	WorkspaceId  openapi_types.UUID      `json:"workspace_id"`
}

// GraphEdge defines model for GraphEdge.
type GraphEdge struct {
	// Confidence AI confidence score
	Confidence *float32   `json:"confidence"`
	CreatedAt  *time.Time `json:"created_at,omitempty"`

	// EdgeType Type of relationship
	EdgeType string `json:"edge_type"`

	// FromNodeId Source node ID
	FromNodeId openapi_types.UUID `json:"from_node_id"`
	GraphId    openapi_types.UUID `json:"graph_id"`
	Id         openapi_types.UUID `json:"id"`

	// IsDirected Whether the edge has direction (arrow)
	IsDirected *bool                   `json:"is_directed,omitempty"`
	Metadata   *map[string]interface{} `json:"metadata"`

	// Style Visual styling (color, width, etc.)
	Style *map[string]interface{} `json:"style"`

	// ToNodeId Target node ID
	ToNodeId  openapi_types.UUID `json:"to_node_id"`
	UpdatedAt *time.Time         `json:"updated_at,omitempty"`

	// Weight Relationship strength (0.0 - 1.0)
	Weight *float32 `json:"weight"`
}

// GraphListItem defines model for GraphListItem.
type GraphListItem struct {
	CreatedAt   time.Time          `json:"created_at"`
	GraphType   *string            `json:"graph_type"`
	Id          openapi_types.UUID `json:"id"`
	Title       string             `json:"title"`
	UpdatedAt   time.Time          `json:"updated_at"`
	WorkspaceId openapi_types.UUID `json:"workspace_id"`
}

// GraphNode defines model for GraphNode.
type GraphNode struct {
	CreatedAt *time.Time         `json:"created_at,omitempty"`
	GraphId   openapi_types.UUID `json:"graph_id"`
	Id        openapi_types.UUID `json:"id"`

	// Label Display name of the node
	Label string `json:"label"`

	// Metadata Additional custom data
	Metadata *map[string]interface{} `json:"metadata"`

	// NodeType Type of node: person, document, concept, etc.
	NodeType string `json:"node_type"`

	// Position 3D position for force-graph
	Position *struct {
		X *float32 `json:"x,omitempty"`
		Y *float32 `json:"y,omitempty"`
		Z *float32 `json:"z"`
	} `json:"position"`

	// SourceId Reference to source entity (e.g., document_chunks.id)
	SourceId *openapi_types.UUID `json:"source_id"`

	// SourceType Where this node came from
	SourceType *string `json:"source_type"`

	// Style Visual styling (color, size, shape, etc.)
	Style *map[string]interface{} `json:"style"`
}

// SourceDocument defines model for SourceDocument.
type SourceDocument struct {
	Chunks []struct {
		ChunkIndex     int    `json:"chunk_index"`
		ContentPreview string `json:"content_preview"`

		// PageNumber Page number this chunk belongs to (1-based)
		PageNumber *int    `json:"page_number"`
		Score      float32 `json:"score"`
	} `json:"chunks"`
	CreatedAt    *time.Time         `json:"created_at,omitempty"`
	DocumentId   openapi_types.UUID `json:"document_id"`
	DocumentName string             `json:"document_name"`
	MimeType     string             `json:"mime_type"`

	// ReferencedPages Page numbers referenced in this document (deduplicated, sorted)
	ReferencedPages *[]int     `json:"referenced_pages,omitempty"`
	SizeBytes       *int64     `json:"size_bytes,omitempty"`
	UpdatedAt       *time.Time `json:"updated_at,omitempty"`
}

// SourcesResponse defines model for SourcesResponse.
type SourcesResponse struct {
	Sources        []SourceDocument `json:"sources"`
	TotalChunks    int              `json:"total_chunks"`
	TotalDocuments int              `json:"total_documents"`
}

// UpdateGraphRequest defines model for UpdateGraphRequest.
type UpdateGraphRequest struct {
	LayoutConfig *map[string]interface{} `json:"layout_config"`
	Title        *string                 `json:"title,omitempty"`
}

// Workspace defines model for Workspace.
type Workspace struct {
	CreatedAt   time.Time               `json:"created_at"`
	Description *string                 `json:"description"`
	Id          openapi_types.UUID      `json:"id"`
	Name        string                  `json:"name"`
	Settings    *map[string]interface{} `json:"settings"`
	UpdatedAt   time.Time               `json:"updated_at"`
}

// BadRequest defines model for BadRequest.
type BadRequest = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// NotFound defines model for NotFound.
type NotFound = Error

// CreateWorkspaceJSONBody defines parameters for CreateWorkspace.
type CreateWorkspaceJSONBody struct {
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
}

// UpdateWorkspaceJSONBody defines parameters for UpdateWorkspace.
type UpdateWorkspaceJSONBody struct {
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// ListAnalysesParams defines parameters for ListAnalyses.
type ListAnalysesParams struct {
	// Status Filter by status
	Status *AnalysisStatus `form:"status,omitempty" json:"status,omitempty"`
	Limit  *int            `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int            `form:"offset,omitempty" json:"offset,omitempty"`
}

// CreateAnalysisJSONBody defines parameters for CreateAnalysis.
type CreateAnalysisJSONBody struct {
	// AnalysisType Type of analysis to perform
	AnalysisType CreateAnalysisJSONBodyAnalysisType `json:"analysis_type"`
	Config       *struct {
		// DocumentIds Target documents (if empty, analyze all in workspace)
		DocumentIds *[]openapi_types.UUID                 `json:"document_ids,omitempty"`
		Language    *CreateAnalysisJSONBodyConfigLanguage `json:"language,omitempty"`
		MaxKeywords *int                                  `json:"max_keywords,omitempty"`
	} `json:"config,omitempty"`
	Description *string `json:"description,omitempty"`
	Title       string  `json:"title"`
}

// CreateAnalysisJSONBodyAnalysisType defines parameters for CreateAnalysis.
type CreateAnalysisJSONBodyAnalysisType string

// CreateAnalysisJSONBodyConfigLanguage defines parameters for CreateAnalysis.
type CreateAnalysisJSONBodyConfigLanguage string

// ListChatsParams defines parameters for ListChats.
type ListChatsParams struct {
	Limit  *int `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// CreateChatJSONBody defines parameters for CreateChat.
type CreateChatJSONBody struct {
	// FilterConfig Configuration for filtering RAG search scope
	FilterConfig *FilterConfig `json:"filter_config,omitempty"`

	// Title Chat title (user-defined or auto-generated)
	Title string `json:"title"`
}

// GetChatParams defines parameters for GetChat.
type GetChatParams struct {
	// MessageLimit Number of recent messages to return
	MessageLimit *int `form:"message_limit,omitempty" json:"message_limit,omitempty"`
}

// SendMessageJSONBody defines parameters for SendMessage.
type SendMessageJSONBody struct {
	// Content User message content
	Content string `json:"content"`
}

// GetDocumentChunksParams defines parameters for GetDocumentChunks.
type GetDocumentChunksParams struct {
	Page  *int `form:"page,omitempty" json:"page,omitempty"`
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ProcessDocumentJSONBody defines parameters for ProcessDocument.
type ProcessDocumentJSONBody struct {
	ChunkOverlap   *int  `json:"chunk_overlap,omitempty"`
	ChunkSize      *int  `json:"chunk_size,omitempty"`
	ForceReprocess *bool `json:"force_reprocess,omitempty"`
}

// ListFilesParams defines parameters for ListFiles.
type ListFilesParams struct {
	// DirectoryId Filter by directory ID
	DirectoryId *openapi_types.UUID `form:"directoryId,omitempty" json:"directoryId,omitempty"`
	Limit       *int                `form:"limit,omitempty" json:"limit,omitempty"`
	Offset      *int                `form:"offset,omitempty" json:"offset,omitempty"`
}

// UploadFileMultipartBody defines parameters for UploadFile.
type UploadFileMultipartBody struct {
	// DirectoryId Target directory (optional)
	DirectoryId *openapi_types.UUID `json:"directoryId"`

	// File The file to upload
	File openapi_types.File `json:"file"`

	// Tags File tags (optional)
	Tags *[]string `json:"tags,omitempty"`
}

// SearchWorkspaceJSONBody defines parameters for SearchWorkspace.
type SearchWorkspaceJSONBody struct {
	Query string `json:"query"`
	TopK  *int   `json:"top_k,omitempty"`
}

// CreateWorkspaceJSONRequestBody defines body for CreateWorkspace for application/json ContentType.
type CreateWorkspaceJSONRequestBody CreateWorkspaceJSONBody

// UpdateWorkspaceJSONRequestBody defines body for UpdateWorkspace for application/json ContentType.
type UpdateWorkspaceJSONRequestBody UpdateWorkspaceJSONBody

// CreateAnalysisJSONRequestBody defines body for CreateAnalysis for application/json ContentType.
type CreateAnalysisJSONRequestBody CreateAnalysisJSONBody

// CreateChatJSONRequestBody defines body for CreateChat for application/json ContentType.
type CreateChatJSONRequestBody CreateChatJSONBody

// SendMessageJSONRequestBody defines body for SendMessage for application/json ContentType.
type SendMessageJSONRequestBody SendMessageJSONBody

// ProcessDocumentJSONRequestBody defines body for ProcessDocument for application/json ContentType.
type ProcessDocumentJSONRequestBody ProcessDocumentJSONBody

// UploadFileMultipartRequestBody defines body for UploadFile for multipart/form-data ContentType.
type UploadFileMultipartRequestBody UploadFileMultipartBody

// SearchWorkspaceJSONRequestBody defines body for SearchWorkspace for application/json ContentType.
type SearchWorkspaceJSONRequestBody SearchWorkspaceJSONBody

// CreateGraphJSONRequestBody defines body for CreateGraph for application/json ContentType.
type CreateGraphJSONRequestBody = CreateGraphRequest

// UpdateGraphJSONRequestBody defines body for UpdateGraph for application/json ContentType.
type UpdateGraphJSONRequestBody = UpdateGraphRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// API health check
	// (GET /health)
	HealthCheck(w http.ResponseWriter, r *http.Request)
	// List all workspaces
	// (GET /workspaces)
	ListWorkspaces(w http.ResponseWriter, r *http.Request)
	// Create a new workspace
	// (POST /workspaces)
	CreateWorkspace(w http.ResponseWriter, r *http.Request)
	// Delete workspace
	// (DELETE /workspaces/{workspaceId})
	DeleteWorkspace(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID)
	// Get workspace by ID
	// (GET /workspaces/{workspaceId})
	GetWorkspace(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID)
	// Update workspace
	// (PATCH /workspaces/{workspaceId})
	UpdateWorkspace(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID)
	// List all analyses in workspace
	// (GET /workspaces/{workspaceId}/analyses)
	ListAnalyses(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, params ListAnalysesParams)
	// Create a new analysis job
	// (POST /workspaces/{workspaceId}/analyses)
	CreateAnalysis(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID)
	// Delete an analysis (soft delete)
	// (DELETE /workspaces/{workspaceId}/analyses/{analysisId})
	DeleteAnalysis(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, analysisId openapi_types.UUID)
	// Get analysis status and metadata
	// (GET /workspaces/{workspaceId}/analyses/{analysisId})
	GetAnalysis(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, analysisId openapi_types.UUID)
	// Get analysis results
	// (GET /workspaces/{workspaceId}/analyses/{analysisId}/results)
	GetAnalysisResults(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, analysisId openapi_types.UUID)
	// List all chats in workspace
	// (GET /workspaces/{workspaceId}/chats)
	ListChats(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, params ListChatsParams)
	// Create a new chat
	// (POST /workspaces/{workspaceId}/chats)
	CreateChat(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID)
	// Delete a chat (soft delete)
	// (DELETE /workspaces/{workspaceId}/chats/{chatId})
	DeleteChat(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, chatId openapi_types.UUID)
	// Get chat details with message history
	// (GET /workspaces/{workspaceId}/chats/{chatId})
	GetChat(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, chatId openapi_types.UUID, params GetChatParams)
	// Send a message and get AI response
	// (POST /workspaces/{workspaceId}/chats/{chatId}/messages)
	SendMessage(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, chatId openapi_types.UUID)
	// Get sources used in chat messages
	// (GET /workspaces/{workspaceId}/chats/{chatId}/sources)
	GetChatSources(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, chatId openapi_types.UUID)
	// Get document chunks
	// (GET /workspaces/{workspaceId}/documents/{documentId}/chunks)
	GetDocumentChunks(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, documentId openapi_types.UUID, params GetDocumentChunksParams)
	// Start document processing
	// (POST /workspaces/{workspaceId}/documents/{documentId}/process)
	ProcessDocument(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, documentId openapi_types.UUID)
	// Get document processing status
	// (GET /workspaces/{workspaceId}/documents/{documentId}/status)
	GetDocumentStatus(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, documentId openapi_types.UUID)
	// List files in workspace
	// (GET /workspaces/{workspaceId}/files)
	ListFiles(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, params ListFilesParams)
	// Upload a file
	// (POST /workspaces/{workspaceId}/files/upload)
	UploadFile(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID)
	// Delete a file
	// (DELETE /workspaces/{workspaceId}/files/{fileId})
	DeleteFile(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, fileId openapi_types.UUID)
	// Get file metadata
	// (GET /workspaces/{workspaceId}/files/{fileId})
	GetFile(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, fileId openapi_types.UUID)
	// Download file content
	// (GET /workspaces/{workspaceId}/files/{fileId}/download)
	DownloadFile(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, fileId openapi_types.UUID)
	// RAG search
	// (POST /workspaces/{workspaceId}/search)
	SearchWorkspace(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID)
	// List all graphs in workspace
	// (GET /workspaces/{workspace_id}/graphs)
	ListGraphs(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID)
	// Create a new graph
	// (POST /workspaces/{workspace_id}/graphs)
	CreateGraph(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID)
	// Delete a graph
	// (DELETE /workspaces/{workspace_id}/graphs/{graph_id})
	DeleteGraph(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, graphId openapi_types.UUID)
	// Get complete graph with nodes and edges
	// (GET /workspaces/{workspace_id}/graphs/{graph_id})
	GetGraph(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, graphId openapi_types.UUID)
	// Update graph metadata
	// (PUT /workspaces/{workspace_id}/graphs/{graph_id})
	UpdateGraph(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, graphId openapi_types.UUID)
	// Get edges only (lightweight)
	// (GET /workspaces/{workspace_id}/graphs/{graph_id}/edges)
	GetGraphEdges(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, graphId openapi_types.UUID)
	// Get nodes only (lightweight)
	// (GET /workspaces/{workspace_id}/graphs/{graph_id}/nodes)
	GetGraphNodes(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, graphId openapi_types.UUID)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// API health check
// (GET /health)
func (_ Unimplemented) HealthCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List all workspaces
// (GET /workspaces)
func (_ Unimplemented) ListWorkspaces(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new workspace
// (POST /workspaces)
func (_ Unimplemented) CreateWorkspace(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete workspace
// (DELETE /workspaces/{workspaceId})
func (_ Unimplemented) DeleteWorkspace(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get workspace by ID
// (GET /workspaces/{workspaceId})
func (_ Unimplemented) GetWorkspace(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update workspace
// (PATCH /workspaces/{workspaceId})
func (_ Unimplemented) UpdateWorkspace(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List all analyses in workspace
// (GET /workspaces/{workspaceId}/analyses)
func (_ Unimplemented) ListAnalyses(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, params ListAnalysesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new analysis job
// (POST /workspaces/{workspaceId}/analyses)
func (_ Unimplemented) CreateAnalysis(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete an analysis (soft delete)
// (DELETE /workspaces/{workspaceId}/analyses/{analysisId})
func (_ Unimplemented) DeleteAnalysis(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, analysisId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get analysis status and metadata
// (GET /workspaces/{workspaceId}/analyses/{analysisId})
func (_ Unimplemented) GetAnalysis(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, analysisId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get analysis results
// (GET /workspaces/{workspaceId}/analyses/{analysisId}/results)
func (_ Unimplemented) GetAnalysisResults(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, analysisId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List all chats in workspace
// (GET /workspaces/{workspaceId}/chats)
func (_ Unimplemented) ListChats(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, params ListChatsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new chat
// (POST /workspaces/{workspaceId}/chats)
func (_ Unimplemented) CreateChat(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a chat (soft delete)
// (DELETE /workspaces/{workspaceId}/chats/{chatId})
func (_ Unimplemented) DeleteChat(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, chatId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get chat details with message history
// (GET /workspaces/{workspaceId}/chats/{chatId})
func (_ Unimplemented) GetChat(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, chatId openapi_types.UUID, params GetChatParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Send a message and get AI response
// (POST /workspaces/{workspaceId}/chats/{chatId}/messages)
func (_ Unimplemented) SendMessage(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, chatId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get sources used in chat messages
// (GET /workspaces/{workspaceId}/chats/{chatId}/sources)
func (_ Unimplemented) GetChatSources(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, chatId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get document chunks
// (GET /workspaces/{workspaceId}/documents/{documentId}/chunks)
func (_ Unimplemented) GetDocumentChunks(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, documentId openapi_types.UUID, params GetDocumentChunksParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Start document processing
// (POST /workspaces/{workspaceId}/documents/{documentId}/process)
func (_ Unimplemented) ProcessDocument(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, documentId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get document processing status
// (GET /workspaces/{workspaceId}/documents/{documentId}/status)
func (_ Unimplemented) GetDocumentStatus(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, documentId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List files in workspace
// (GET /workspaces/{workspaceId}/files)
func (_ Unimplemented) ListFiles(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, params ListFilesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Upload a file
// (POST /workspaces/{workspaceId}/files/upload)
func (_ Unimplemented) UploadFile(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a file
// (DELETE /workspaces/{workspaceId}/files/{fileId})
func (_ Unimplemented) DeleteFile(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, fileId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get file metadata
// (GET /workspaces/{workspaceId}/files/{fileId})
func (_ Unimplemented) GetFile(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, fileId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Download file content
// (GET /workspaces/{workspaceId}/files/{fileId}/download)
func (_ Unimplemented) DownloadFile(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, fileId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// RAG search
// (POST /workspaces/{workspaceId}/search)
func (_ Unimplemented) SearchWorkspace(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List all graphs in workspace
// (GET /workspaces/{workspace_id}/graphs)
func (_ Unimplemented) ListGraphs(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new graph
// (POST /workspaces/{workspace_id}/graphs)
func (_ Unimplemented) CreateGraph(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a graph
// (DELETE /workspaces/{workspace_id}/graphs/{graph_id})
func (_ Unimplemented) DeleteGraph(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, graphId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get complete graph with nodes and edges
// (GET /workspaces/{workspace_id}/graphs/{graph_id})
func (_ Unimplemented) GetGraph(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, graphId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update graph metadata
// (PUT /workspaces/{workspace_id}/graphs/{graph_id})
func (_ Unimplemented) UpdateGraph(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, graphId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get edges only (lightweight)
// (GET /workspaces/{workspace_id}/graphs/{graph_id}/edges)
func (_ Unimplemented) GetGraphEdges(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, graphId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get nodes only (lightweight)
// (GET /workspaces/{workspace_id}/graphs/{graph_id}/nodes)
func (_ Unimplemented) GetGraphNodes(w http.ResponseWriter, r *http.Request, workspaceId openapi_types.UUID, graphId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HealthCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListWorkspaces operation middleware
func (siw *ServerInterfaceWrapper) ListWorkspaces(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListWorkspaces(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateWorkspace operation middleware
func (siw *ServerInterfaceWrapper) CreateWorkspace(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateWorkspace(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteWorkspace operation middleware
func (siw *ServerInterfaceWrapper) DeleteWorkspace(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteWorkspace(w, r, workspaceId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetWorkspace operation middleware
func (siw *ServerInterfaceWrapper) GetWorkspace(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetWorkspace(w, r, workspaceId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateWorkspace operation middleware
func (siw *ServerInterfaceWrapper) UpdateWorkspace(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateWorkspace(w, r, workspaceId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListAnalyses operation middleware
func (siw *ServerInterfaceWrapper) ListAnalyses(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAnalysesParams

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListAnalyses(w, r, workspaceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateAnalysis operation middleware
func (siw *ServerInterfaceWrapper) CreateAnalysis(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateAnalysis(w, r, workspaceId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteAnalysis operation middleware
func (siw *ServerInterfaceWrapper) DeleteAnalysis(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	// ------------- Path parameter "analysisId" -------------
	var analysisId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "analysisId", chi.URLParam(r, "analysisId"), &analysisId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "analysisId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteAnalysis(w, r, workspaceId, analysisId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAnalysis operation middleware
func (siw *ServerInterfaceWrapper) GetAnalysis(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	// ------------- Path parameter "analysisId" -------------
	var analysisId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "analysisId", chi.URLParam(r, "analysisId"), &analysisId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "analysisId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnalysis(w, r, workspaceId, analysisId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAnalysisResults operation middleware
func (siw *ServerInterfaceWrapper) GetAnalysisResults(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	// ------------- Path parameter "analysisId" -------------
	var analysisId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "analysisId", chi.URLParam(r, "analysisId"), &analysisId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "analysisId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnalysisResults(w, r, workspaceId, analysisId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListChats operation middleware
func (siw *ServerInterfaceWrapper) ListChats(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ListChatsParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListChats(w, r, workspaceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateChat operation middleware
func (siw *ServerInterfaceWrapper) CreateChat(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateChat(w, r, workspaceId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteChat operation middleware
func (siw *ServerInterfaceWrapper) DeleteChat(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	// ------------- Path parameter "chatId" -------------
	var chatId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "chatId", chi.URLParam(r, "chatId"), &chatId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "chatId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteChat(w, r, workspaceId, chatId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetChat operation middleware
func (siw *ServerInterfaceWrapper) GetChat(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	// ------------- Path parameter "chatId" -------------
	var chatId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "chatId", chi.URLParam(r, "chatId"), &chatId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "chatId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetChatParams

	// ------------- Optional query parameter "message_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "message_limit", r.URL.Query(), &params.MessageLimit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "message_limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetChat(w, r, workspaceId, chatId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SendMessage operation middleware
func (siw *ServerInterfaceWrapper) SendMessage(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	// ------------- Path parameter "chatId" -------------
	var chatId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "chatId", chi.URLParam(r, "chatId"), &chatId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "chatId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SendMessage(w, r, workspaceId, chatId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetChatSources operation middleware
func (siw *ServerInterfaceWrapper) GetChatSources(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	// ------------- Path parameter "chatId" -------------
	var chatId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "chatId", chi.URLParam(r, "chatId"), &chatId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "chatId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetChatSources(w, r, workspaceId, chatId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocumentChunks operation middleware
func (siw *ServerInterfaceWrapper) GetDocumentChunks(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	// ------------- Path parameter "documentId" -------------
	var documentId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", chi.URLParam(r, "documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDocumentChunksParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocumentChunks(w, r, workspaceId, documentId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ProcessDocument operation middleware
func (siw *ServerInterfaceWrapper) ProcessDocument(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	// ------------- Path parameter "documentId" -------------
	var documentId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", chi.URLParam(r, "documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProcessDocument(w, r, workspaceId, documentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocumentStatus operation middleware
func (siw *ServerInterfaceWrapper) GetDocumentStatus(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	// ------------- Path parameter "documentId" -------------
	var documentId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "documentId", chi.URLParam(r, "documentId"), &documentId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "documentId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocumentStatus(w, r, workspaceId, documentId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListFiles operation middleware
func (siw *ServerInterfaceWrapper) ListFiles(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ListFilesParams

	// ------------- Optional query parameter "directoryId" -------------

	err = runtime.BindQueryParameter("form", true, false, "directoryId", r.URL.Query(), &params.DirectoryId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "directoryId", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListFiles(w, r, workspaceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UploadFile operation middleware
func (siw *ServerInterfaceWrapper) UploadFile(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadFile(w, r, workspaceId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteFile operation middleware
func (siw *ServerInterfaceWrapper) DeleteFile(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	// ------------- Path parameter "fileId" -------------
	var fileId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "fileId", chi.URLParam(r, "fileId"), &fileId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fileId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteFile(w, r, workspaceId, fileId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetFile operation middleware
func (siw *ServerInterfaceWrapper) GetFile(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	// ------------- Path parameter "fileId" -------------
	var fileId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "fileId", chi.URLParam(r, "fileId"), &fileId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fileId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFile(w, r, workspaceId, fileId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DownloadFile operation middleware
func (siw *ServerInterfaceWrapper) DownloadFile(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	// ------------- Path parameter "fileId" -------------
	var fileId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "fileId", chi.URLParam(r, "fileId"), &fileId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fileId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DownloadFile(w, r, workspaceId, fileId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SearchWorkspace operation middleware
func (siw *ServerInterfaceWrapper) SearchWorkspace(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspaceId" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspaceId", chi.URLParam(r, "workspaceId"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspaceId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SearchWorkspace(w, r, workspaceId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListGraphs operation middleware
func (siw *ServerInterfaceWrapper) ListGraphs(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspace_id" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspace_id", chi.URLParam(r, "workspace_id"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGraphs(w, r, workspaceId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateGraph operation middleware
func (siw *ServerInterfaceWrapper) CreateGraph(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspace_id" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspace_id", chi.URLParam(r, "workspace_id"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateGraph(w, r, workspaceId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteGraph operation middleware
func (siw *ServerInterfaceWrapper) DeleteGraph(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspace_id" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspace_id", chi.URLParam(r, "workspace_id"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace_id", Err: err})
		return
	}

	// ------------- Path parameter "graph_id" -------------
	var graphId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "graph_id", chi.URLParam(r, "graph_id"), &graphId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "graph_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGraph(w, r, workspaceId, graphId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetGraph operation middleware
func (siw *ServerInterfaceWrapper) GetGraph(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspace_id" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspace_id", chi.URLParam(r, "workspace_id"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace_id", Err: err})
		return
	}

	// ------------- Path parameter "graph_id" -------------
	var graphId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "graph_id", chi.URLParam(r, "graph_id"), &graphId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "graph_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGraph(w, r, workspaceId, graphId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateGraph operation middleware
func (siw *ServerInterfaceWrapper) UpdateGraph(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspace_id" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspace_id", chi.URLParam(r, "workspace_id"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace_id", Err: err})
		return
	}

	// ------------- Path parameter "graph_id" -------------
	var graphId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "graph_id", chi.URLParam(r, "graph_id"), &graphId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "graph_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateGraph(w, r, workspaceId, graphId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetGraphEdges operation middleware
func (siw *ServerInterfaceWrapper) GetGraphEdges(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspace_id" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspace_id", chi.URLParam(r, "workspace_id"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace_id", Err: err})
		return
	}

	// ------------- Path parameter "graph_id" -------------
	var graphId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "graph_id", chi.URLParam(r, "graph_id"), &graphId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "graph_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGraphEdges(w, r, workspaceId, graphId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetGraphNodes operation middleware
func (siw *ServerInterfaceWrapper) GetGraphNodes(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workspace_id" -------------
	var workspaceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "workspace_id", chi.URLParam(r, "workspace_id"), &workspaceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace_id", Err: err})
		return
	}

	// ------------- Path parameter "graph_id" -------------
	var graphId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "graph_id", chi.URLParam(r, "graph_id"), &graphId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "graph_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGraphNodes(w, r, workspaceId, graphId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/health", wrapper.HealthCheck)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workspaces", wrapper.ListWorkspaces)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/workspaces", wrapper.CreateWorkspace)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/workspaces/{workspaceId}", wrapper.DeleteWorkspace)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workspaces/{workspaceId}", wrapper.GetWorkspace)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/workspaces/{workspaceId}", wrapper.UpdateWorkspace)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workspaces/{workspaceId}/analyses", wrapper.ListAnalyses)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/workspaces/{workspaceId}/analyses", wrapper.CreateAnalysis)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/workspaces/{workspaceId}/analyses/{analysisId}", wrapper.DeleteAnalysis)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workspaces/{workspaceId}/analyses/{analysisId}", wrapper.GetAnalysis)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workspaces/{workspaceId}/analyses/{analysisId}/results", wrapper.GetAnalysisResults)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workspaces/{workspaceId}/chats", wrapper.ListChats)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/workspaces/{workspaceId}/chats", wrapper.CreateChat)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/workspaces/{workspaceId}/chats/{chatId}", wrapper.DeleteChat)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workspaces/{workspaceId}/chats/{chatId}", wrapper.GetChat)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/workspaces/{workspaceId}/chats/{chatId}/messages", wrapper.SendMessage)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workspaces/{workspaceId}/chats/{chatId}/sources", wrapper.GetChatSources)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workspaces/{workspaceId}/documents/{documentId}/chunks", wrapper.GetDocumentChunks)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/workspaces/{workspaceId}/documents/{documentId}/process", wrapper.ProcessDocument)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workspaces/{workspaceId}/documents/{documentId}/status", wrapper.GetDocumentStatus)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workspaces/{workspaceId}/files", wrapper.ListFiles)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/workspaces/{workspaceId}/files/upload", wrapper.UploadFile)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/workspaces/{workspaceId}/files/{fileId}", wrapper.DeleteFile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workspaces/{workspaceId}/files/{fileId}", wrapper.GetFile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workspaces/{workspaceId}/files/{fileId}/download", wrapper.DownloadFile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/workspaces/{workspaceId}/search", wrapper.SearchWorkspace)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workspaces/{workspace_id}/graphs", wrapper.ListGraphs)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/workspaces/{workspace_id}/graphs", wrapper.CreateGraph)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/workspaces/{workspace_id}/graphs/{graph_id}", wrapper.DeleteGraph)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workspaces/{workspace_id}/graphs/{graph_id}", wrapper.GetGraph)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/workspaces/{workspace_id}/graphs/{graph_id}", wrapper.UpdateGraph)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workspaces/{workspace_id}/graphs/{graph_id}/edges", wrapper.GetGraphEdges)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workspaces/{workspace_id}/graphs/{graph_id}/nodes", wrapper.GetGraphNodes)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xdX28ct3b/KsS0wJWBlXalSL6JgPugyLEjNHYMO2keAmFBzZzdpT07nJAcyWtBDwaK",
	"Io9FgaLoSwsURYCiaNGHvvS+9MO4yf0aF/w7/zg7s7uzq8TJk+UdDslz+Dt/eHh45jYI6TylCSSCB6e3",
	"AQOe0oSD+s+nOHoB32XAhfxfSBMBifoTp2lMQiwITYavOE3kbzycwRzLv/6SwSQ4Df5imHc91E/58DPG",
	"KAvu7u4GQQQ8ZCSVnQSncizEzGB3g+AiEcASHL8Edg1Mv7X1OdhBEVejItANB8EzKh7TLIm2P4UXwGnG",
	"QkAJFWiixpSNzHuy27MExwtO1N8poykwQfRyYfNkLBYpyB8gyebB6bcBz+ZzzBbBIHgNixvKojG8EQyH",
	"asxBAIkgYjFmENJpQsyPU4bT2XgKCTBsfuKy4RwSMbYjBZeDQA8WcMFIMpXMkuTGICAaY8WlCWVz+VcQ",
	"YQH7sodgECRZHOOrGIJTwTLw9pJMyFSRFUVqUjh+XiBXv1ZmnmXNPk8hJBMSIt1L5khoGJZevYJQ4S5k",
	"gFumXptqaRK37aQpWI3nwDmeqnUqU6GwgSIQmMQckQniAouMI8LR7yaYxBD9rgsDSVSiIMtI5Js8F5ht",
	"ulZ6gm2Yt6vzUre+GwSCiFgxoNZjlkYrL8MNZa95ikMYdyL9bhBIfUMYRFJGVJNSF3Z+g4pgOXpLaCnN",
	"+dKDLEv+C+BZLJZIb8eFK+qhzhKiB0cRFhjtccGyUGQMUAQpJBFHNEFMtVCUPgh6EpCOFJE5nsI4Y3Fd",
	"Jr5+8QUSFBl1BBFSbdEemRQn/Af1q5x2PhYjXRA8B4ElU1bUN64lsh0gfEUzgcQMzMS6KJ0CCXXSv1qk",
	"gKilE9llHzjtLuCN/K8yQIaJVn979LMP9kXolWdTWu9lqH7pVIBfJaNX9Ao5ubFTl6iTsxoELEsS/Zcz",
	"H3IZlbrzWpnzGfYI0TronJBYABvnBmeZEnusGp/rtt2hHWMurMY3k6usMpkDF3ieyqWW6JFvIGsjBmsq",
	"ZjtiSLPENygVOEZJNr8CJsc1zTkiCRIzwlE4U5ptThIylys2cmOQRMAU2C9Ji6+irCW6nuYGugKyGRZr",
	"aOn6s3V8DRpmygVjMPGI2wuYAIMkBC7VpXEl7Tsc7b04e4JCIpQ7xKWiJALmrZb7kenA9a6WXU8NM4YX",
	"K0iChSRJInhTJ+Cl3AIkguAYqRbohoiZgiMoNKK90f4V5hA9aMUlo3HJC844MKnsOCdcYKVC+YILmHfU",
	"knbZTc/52laJalWa5+rxE6mhC/urMsi0/+08+TdYasXgNHid0JsYoimMtYbvoAWcgOa9HI2Ojn/83//5",
	"8Y8//P8fv//Tf/3jj9//7U///HeSEvzmC0imYhacHp2cKBbb/x+2cUmP4yO4DiCPUGXJ6xwVy5fWcH6c",
	"MrgmcOOB0Ywygcxjq1LVEAUDWqR1NFombB2x7doneO7XiKlEiVa49Uk/ly6N0cYG8hUJRnuHHvQfNmKg",
	"wDIeUgY+hRHDNU5CQKoB2hsdjNA+OjwYldyoSUyxYZkb07NEhrIqMIp8HJRW2s7LBxq36S8DBfw/hzTy",
	"s9xspArP8iEKe7DaeyYYYdbeI1TGYHue3tWoufPQ95jE8AXh4oUJudRpmpBY/9FJS8v+nlo/1qOghbT2",
	"7U6AGhTNsQhnJJkqFH6XgYoeVFFVWWY9XTvQZQPJTwuuttd5O1vNd4NnRtjKZH3JyJRIz1w2UfK4/sZk",
	"Tubwldc5f3rx9DMk26M9OJgeDFAxJJRGkwfeLfcMH508/BzzmUdxfX52dPIQzTCf2cUoaKx6V+QtfLoQ",
	"4HEFJK+RfC51yZVqUxBokoiHx4FXUTR48laHo5TREDiX4Kg59FkaUxwp3z1vlv+nzakXeNpEiXyEJpSh",
	"EAuYUkbe2piOE45adw1a0UiEz8Y7PBUWvcjlQQGkTQD/WvGgWao3hHkfIF4bkhMVmYoyB/JWULYibkvL",
	"kO/SagSdF4OCiiS9BZSIlg4yB8zCmTSIatjy6kWEQSgoW4xJxH3+q3rXeK0uDmnfImryDrGti1bV4QVL",
	"6hvcDec8frkL0FPag3kqFugPCMfxg40m0SilAhi6WuTeimq4TEBrAllbSeUkq6hMHH85CU6/XW4DVXNp",
	"VC+kX383qDkP0XQFi6p6+yyaevc7MV7QTIzXiVM/piyEfeW/I91NOVCN9tLZgpOQD9BbSucDBCI8eNAl",
	"kpTQaFX6nknH6a5FOep+B4Z/dZG7tEuluOVxzpIJiazjX4kQXaD8sfZC5UB2qzI6+OTI44g2cMI6oOtt",
	"rtW2qi0KF+vN84ykxWnqoMN4QplXfzM6H0seGm+yIrb2xCcCdPGoFL1skEi9OewaVu3YjI+1lgIzxQlW",
	"cWofgL+ZgZgBU86hZJo0DkbHKfhixuhNwfe5ojQGnKwSaW2FOhcLvavtLnd/TXiGYyTflLp+L6QxZQN0",
	"QyIxW0HIBG1ey68wm4JYZS3XCpIBmc6Edzfn0Im4YGp3W9nTFSTr45PVJctnrh0cK0gvsaooXpdNmt6p",
	"7l4iuz3GUPRa510cHn0ExycPf78PH39ytX94FH20j49PHu4fHz18eHh8+Pvj0WjUZfW3Fpv5JUdfc7vU",
	"Iwz61ZYxvgLPZvoR4WmMF0huOG3YSQpAyVScxSQE9HJOxCzYxllUmHFB5+qQr6vP0GL1ZJNTlALjNBk4",
	"/24gDXcIqdC6s0SjbusjL6Wc2KPy8mgfPUL2ofbKczfJQ0cZF28K/mXuBCy8v75dckpfUHN1i6PstFft",
	"u8BmIeyu0ypsYMB57ir8xQ9I9MCjH9qP2vUc/Mv1zQwY6JMbZYBCiUKpkUtLU55Jt/P9vkyt3MINEJ/h",
	"FDob3BaLoyWxCGOfStE+lo1hNISfy57z0vh0p5j0+uFfc/qWJa/RFcQ0maqdXA/R35q5X27efbHaOqk+",
	"hle3SxsddvUWf5+TeS48npCvkeJoLFeKL10jjvLm7sA0D9TnURKIBohTJvS6VTfDxYPUCsuksIyvOgdS",
	"1rH4SwP1ZXYWmTew8tIsarw5AKZ1WPdtakV2m0Lb41yGPbxVLVxcxNeowgs7y/q7lfF8PPharcTyE76V",
	"AgjtmxLrSK56glfr6RvrwPXjfa2aHddR1htFnIMQJNERqo04urE0aYuuZae7+yt7IcmE1pXPFzTE8f6E",
	"MC7Q2UWua2z6DsJJhNzeBun4UhpjIefuXPHT4Bm8yTg6e34RDIJrYFz3fngwOhhJumkKCU6JdMgORgcf",
	"BdJsiZni53AGOBYqHjcFxRbJVbXlvIiC0+Bz9fh8BuFrnUiU5xIfjUYrZc9WVIY7lGg/aqvl1H75VzqH",
	"1mTBngZnzy+QpgSFaq7y8dBtXHgjfXJ7+k3erFcSy8N3Uoy5pHaIpXbgiyQP4ThGN0Uadbj32+IEL7Uf",
	"7+GQTm3IJ+bOUT+l0WID7lS0SFd1UA1jylZ+kcubSXVwV1vaw95yvwurVl8Tzb9IknS8IpzWTru3FqoM",
	"Bj0ThFECNzkgmvBQFqDhrfv7IrrT6xeDgDpeHqnfy3gp8f24rgefUXRumKLYdNxEvetq6BL4yzTq0dup",
	"G/jVwRMQS2Y+2g1ipBRvxoUnIHIWoKuFDlw2iT1meA4CGFeHMUROQdoHa+pOg8LSB1W5GhQobostXSrD",
	"E87qfNfe1c9JyayhUHYED82raFOM6G420wND7ai02Ncz26iGtabzRpeFoMBok1UMGt3DbrysXlK4G9x6",
	"u43JnIhSr+7A5GRUzJMajcp79fquwz8AnUw4NIwwWp76KCWnR8ekuGqd3BJ3Q2lZElLL7gvnKGhKJ9qG",
	"KnQekB1f7ux9oHfz271OXOJ3Oc73pRFrV8r88WG3AxEUpcDMfuO+rp/Z/XRFuS9NnTDndoVUaTJBKmNi",
	"oKl7CwoXRThslkUR42SauQtgRrKDV7jAOJBkv8JeMuf4zdiwk5e6OFpR/dQ3vhUzWAgoHI68ebJrxx7q",
	"2cPVy1brOetHvdnWXJfV1U3pbovZ4Ks9+HcZZCUffrkuKlyz3VB9lXx2XJieX3N1MtbDW9tRJ1e+pIJ2",
	"7snjJCd7j9OJQHq2D5pUd5Nf30zGaCfY6serd7wwV0glON3x4r0bs4G39xxtm1nK1cE91Dffmt3TAi5e",
	"mKa9elqF8VdytMyV0rYkLtv91lwp+cIn249ZOL2bUIHcdUG0ALFMBJhbsV8v7MMZFst3X+eqhZ8dv94t",
	"kONbJ7FUV1PXv4ARmiVo2SG5ZvexPVKDN+2N9Mw8QlXJVnAhJxVvur9d07m+5drPjmmj28TOka4EhWdY",
	"IPUM7WUc2H4EE5JAhChDOBN0392Lf7ClK3y7jZBrAfIExyUfrKPNszAEzidZHC/u29U296SrAtCui4e3",
	"8p9OjrVD6e6danPztsGfzsW9yWkyU1+qDZ45/ccghETkl9EFRQxExpKGCJ+9fNufPerfeHQ1GZbolWyN",
	"vaje5v/Z2/x2jN3YDOmEKfzYijY3RMzs6qIZ4YLqy4Vt1mPnLpkWzW27Y04FDIuL/yHQ3mR1X0ISPXWV",
	"Lfoxu4XXKucfHJhDm/fu9+FoZDRCZzNp+9mFoawEZG31gmL9qBUUhHQf1nq1woFSPwPPtLooF9M54jqL",
	"JUKWUXmhn91Y9kFw0mUMX1G6srKT0EbY4U3SNAWVrWN72cxNGBZy55ZZ25cueW1r0atqmt/WjIchGWVc",
	"J1oqY+J05a/ScLhjiuGt/VNjxSZANmHDJlGe65Y9+zk9pVD3Viyn6x2W1uRl7Vp655yW60dUU04bjjpb",
	"VaPaaatggGJqD2Lk0gVDu/ZWcPLM1p+D8OSA7qXzymYh1fbKs0c4XC9ItWTXseJJ3Foibwor/Bxcxp4W",
	"rtFtfK5JdXngvbmOSi3Ra2AxTpu3jSejUVvFKd0TJ2+h0k2xn6NRGQkjb1fq7tOYQWF9XX8THHOo3631",
	"qZVNj0bLnFpWLifP0HXF/fICIJeDdfJ2n5cKjbAdeoM7OcZwBVUIRzhmgKMFugJJbV4tpeJdSi7kirxU",
	"YcWnzNdRKPk6tvkQL21mVY8+hCvutPy2X2Oxp2aE+sy84/NG1W9TRqfMyGjLtJXlHRtXpsEHyhiDRIy5",
	"gNR/hwxYCIlocDu89xZrorlRmZ7VRdeU+72vTVnJ+/FVL/qgHaHlboUrMdZ4IvjYVPXqmIzp6uMUTnUq",
	"LpNroijb2KX7oM8h2wq+lQrIbe/MTxeFazjv0xjacSJkO6qHWsvt1jVu9F51VTC5ZEsd13kWC5JiJoZy",
	"pH1bB6AxY70gSo05jU4i92iqb8OtdfVcMtUzyAx0lTpBkWF4oe8rkuBi6cDupd5Kc12hglS1IOG9H2Z6",
	"SsJ55FQRbs1y09nmDq8CbXpbQBKCsEKGR1N0EN5b+U+ng1EnU/dwMNpAX/NRqH+y/dqEvAjotkKySuA9",
	"iYT3YQn8zpNGz9ZNjEXpMKI3ibU23rV/ZBqsDgAaChD7XDDA8zIQWtVsg54Je5ICQ1KtSumvDw26xuLP",
	"xNXQNSj7vx6n3eJSraqf/v1ffvrX//7xP3/40//9/ft3//H+3b+9f/c379/98NM//NP7d9+/f/dD/ai1",
	"tW6VoOn4ddmNL4XPWi80FF0APefLHdzQq16c4Te+Ii9nF3myFtKNkKrpor+9IhiBa4i0ML3xl/zNTwC9",
	"ZQR1kEGflk0os4OUrtJs44Bm1WItDQXJX5I5iTEjYmEqkk8YnaNr5cGaUqa+wuTrFyDP9VZzKfKlXqZZ",
	"6nxluhx9mzqxJilZ58RUgfELO/vOS+cWbID5YYnLNybR3VBd91oeh3iim6xkTOwHbTZQsT3qhJzI7tVZ",
	"C7Vsl6PQdH65wtmieSWHTFN+buFbdA4tnb6c508e1uM2RRPMh4taKkw8MVXhdg2G9ezo0iyb+sdAdrxD",
	"1bz0AEU9aEu4rQLhGsek9CnHnYCrlI5rSwZWIdVFBw1vbW25DlvPe0Ch38Et1MPrU9t5Fk5jQrPFh4nG",
	"V/pZZ7fzblrj5q33h75Yo+0rhHNz2crUllIfvFOui6oPrtLddIXw5VCgrFBvpB9cqCzj8uy8E/PamUw0",
	"1Rj5ADHTvwXzFLvbcQWUFgtm6q31a8H61GqmuorGrSeutqYBG7rPHSzViZ8ZyfhNMXoSEvr6YETFXW/6",
	"kEKLt95JvfanUdVoiCbxAu3FZDoTuvD8gx6g6b5UsRSaz8x3J36DZh2a2/3Wx+rQ1O/tCprasHeDpqoK",
	"KnvzpS7ENMQxiuAaYpqqFBFIrgmjiUkyVN8jDmZCpKfDoWo8o1ycfjz6eDTEKRleHwZ3l3d/DgAA//+o",
	"BoFDSH8AAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
